/* DO NOT EDIT THIS FILE - it is machine generated */

#include "Boussinesq.h"
#include <rapidjson/document.h>
#include <rapidjson/istreamwrapper.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>


/******************** Free functions definitions ********************/

namespace boussinesqfreefuncs
{
template<size_t x>
RealArray1D<x> sumR1(RealArray1D<x> a, RealArray1D<x> b)
{
	return boussinesqfreefuncs::operatorAdd(a, b);
}

double maxR0(double a, double b)
{
	return std::max(a, b);
}

template<size_t x0>
RealArray1D<x0> operatorAdd(RealArray1D<x0> a, RealArray1D<x0> b)
{
	RealArray1D<x0> result;
	for (size_t ix0=0; ix0<x0; ix0++)
	{
		result[ix0] = a[ix0] + b[ix0];
	}
	return result;
}

template<size_t x0>
RealArray1D<x0> operatorMult(double a, RealArray1D<x0> b)
{
	RealArray1D<x0> result;
	for (size_t ix0=0; ix0<x0; ix0++)
	{
		result[ix0] = a * b[ix0];
	}
	return result;
}
}

/******************** Module definition ********************/

Boussinesq::Boussinesq(CartesianMesh2D& aMesh)
: mesh(aMesh)
, nbNodes(mesh.getNbNodes())
, nbCells(mesh.getNbCells())
, nbInnerCells(mesh.getGroup("InnerCells").size())
, nbTopCells(mesh.getGroup("TopCells").size())
, nbBottomCells(mesh.getGroup("BottomCells").size())
, nbLeftCells(mesh.getGroup("LeftCells").size())
, nbRightCells(mesh.getGroup("RightCells").size())
, X(nbNodes)
, center(nbCells)
, H_n(nbCells)
, H_nplus1(nbCells)
, H_n0(nbCells)
, Hcalc_n(nbCells)
, Hcalc_nplus1(nbCells)
, Hini(nbCells)
, A("A", nbCells, nbCells)
, B_n("B_n", nbCells)
, B_nplus1("B_nplus1", nbCells)
, B_n0("B_n0", nbCells)
, B_nplus1_k("B_nplus1_k", nbCells)
, B_nplus1_kplus1("B_nplus1_kplus1", nbCells)
, C("C", nbCells, nbCells)
, D_n("D_n", nbCells)
, D_nplus1("D_nplus1", nbCells)
, D_n0("D_n0", nbCells)
, D_nplus1_k("D_nplus1_k", nbCells)
, D_nplus1_kplus1("D_nplus1_kplus1", nbCells)
, Mcalc_n(nbCells)
, Mcalc_nplus1(nbCells)
, M_n(nbCells)
, M_nplus1(nbCells)
, M_n0(nbCells)
, Mm_n(nbCells)
, Mm_nplus1(nbCells)
, Mm_n0(nbCells)
, Mcurr_n("Mcurr_n", nbCells)
, Mcurr_nplus1("Mcurr_nplus1", nbCells)
, Mcurr_nplus1_k("Mcurr_nplus1_k", nbCells)
, Mcurr_nplus1_kplus1("Mcurr_nplus1_kplus1", nbCells)
, Ncalc_n(nbCells)
, Ncalc_nplus1(nbCells)
, N_n(nbCells)
, N_nplus1(nbCells)
, N_n0(nbCells)
, Nm_n(nbCells)
, Nm_nplus1(nbCells)
, Nm_n0(nbCells)
, Ncurr_n("Ncurr_n", nbCells)
, Ncurr_nplus1("Ncurr_nplus1", nbCells)
, Ncurr_nplus1_k("Ncurr_nplus1_k", nbCells)
, Ncurr_nplus1_kplus1("Ncurr_nplus1_kplus1", nbCells)
, Dijini(nbCells)
, Dij(nbCells)
, Dt_n(nbCells)
, Dt_nplus1(nbCells)
, Dt_n0(nbCells)
{
}

Boussinesq::~Boussinesq()
{
}

void
Boussinesq::jsonInit(const char* jsonContent)
{
	rapidjson::Document document;
	assert(!document.Parse(jsonContent).HasParseError());
	assert(document.IsObject());
	const rapidjson::Value::Object& options = document.GetObject();

	assert(options.HasMember("outputPath"));
	const rapidjson::Value& valueof_outputPath = options["outputPath"];
	assert(valueof_outputPath.IsString());
	outputPath = valueof_outputPath.GetString();
	writer = new PvdFileWriter2D("Boussinesq", outputPath);
	assert(options.HasMember("outputPeriod"));
	const rapidjson::Value& valueof_outputPeriod = options["outputPeriod"];
	assert(valueof_outputPeriod.IsInt());
	outputPeriod = valueof_outputPeriod.GetInt();
	lastDump = numeric_limits<int>::min();
	n = 0;
	k = 0;
	assert(options.HasMember("X_EDGE_LENGTH"));
	const rapidjson::Value& valueof_X_EDGE_LENGTH = options["X_EDGE_LENGTH"];
	assert(valueof_X_EDGE_LENGTH.IsDouble());
	X_EDGE_LENGTH = valueof_X_EDGE_LENGTH.GetDouble();
	assert(options.HasMember("Y_EDGE_LENGTH"));
	const rapidjson::Value& valueof_Y_EDGE_LENGTH = options["Y_EDGE_LENGTH"];
	assert(valueof_Y_EDGE_LENGTH.IsDouble());
	Y_EDGE_LENGTH = valueof_Y_EDGE_LENGTH.GetDouble();
	assert(options.HasMember("deltat"));
	const rapidjson::Value& valueof_deltat = options["deltat"];
	assert(valueof_deltat.IsDouble());
	deltat = valueof_deltat.GetDouble();
	assert(options.HasMember("maxIter"));
	const rapidjson::Value& valueof_maxIter = options["maxIter"];
	assert(valueof_maxIter.IsInt());
	maxIter = valueof_maxIter.GetInt();
	assert(options.HasMember("maxIterationsK"));
	const rapidjson::Value& valueof_maxIterationsK = options["maxIterationsK"];
	assert(valueof_maxIterationsK.IsInt());
	maxIterationsK = valueof_maxIterationsK.GetInt();
	assert(options.HasMember("stopTime"));
	const rapidjson::Value& valueof_stopTime = options["stopTime"];
	assert(valueof_stopTime.IsDouble());
	stopTime = valueof_stopTime.GetDouble();
	assert(options.HasMember("loadWave"));
	const rapidjson::Value& valueof_loadWave = options["loadWave"];
	assert(valueof_loadWave.IsBool());
	loadWave = valueof_loadWave.GetBool();
	assert(options.HasMember("waveMode"));
	const rapidjson::Value& valueof_waveMode = options["waveMode"];
	assert(valueof_waveMode.IsInt());
	waveMode = valueof_waveMode.GetInt();
	assert(options.HasMember("X0"));
	const rapidjson::Value& valueof_X0 = options["X0"];
	assert(valueof_X0.IsDouble());
	X0 = valueof_X0.GetDouble();
	assert(options.HasMember("Y0"));
	const rapidjson::Value& valueof_Y0 = options["Y0"];
	assert(valueof_Y0.IsDouble());
	Y0 = valueof_Y0.GetDouble();
	assert(options.HasMember("Amp"));
	const rapidjson::Value& valueof_Amp = options["Amp"];
	assert(valueof_Amp.IsDouble());
	Amp = valueof_Amp.GetDouble();
	assert(options.HasMember("Sigma"));
	const rapidjson::Value& valueof_Sigma = options["Sigma"];
	assert(valueof_Sigma.IsDouble());
	Sigma = valueof_Sigma.GetDouble();
	assert(options.HasMember("loadBathy"));
	const rapidjson::Value& valueof_loadBathy = options["loadBathy"];
	assert(valueof_loadBathy.IsBool());
	loadBathy = valueof_loadBathy.GetBool();
	assert(options.HasMember("LX"));
	const rapidjson::Value& valueof_LX = options["LX"];
	assert(valueof_LX.IsDouble());
	LX = valueof_LX.GetDouble();
	assert(options.HasMember("Dini"));
	const rapidjson::Value& valueof_Dini = options["Dini"];
	assert(valueof_Dini.IsDouble());
	Dini = valueof_Dini.GetDouble();
	assert(options.HasMember("Dup"));
	const rapidjson::Value& valueof_Dup = options["Dup"];
	assert(valueof_Dup.IsDouble());
	Dup = valueof_Dup.GetDouble();
	assert(options.HasMember("epsilon"));
	const rapidjson::Value& valueof_epsilon = options["epsilon"];
	assert(valueof_epsilon.IsDouble());
	epsilon = valueof_epsilon.GetDouble();
	deltax = X_EDGE_LENGTH;
	deltay = Y_EDGE_LENGTH;
	// bathyLib
	if (options.HasMember("bathyLib"))
	{
		rapidjson::StringBuffer strbuf;
		rapidjson::Writer<rapidjson::StringBuffer> writer(strbuf);
		options["bathyLib"].Accept(writer);
		bathyLib.jsonInit(strbuf.GetString());
	}
	// linearAlgebra
	if (options.HasMember("linearAlgebra"))
	{
		rapidjson::StringBuffer strbuf;
		rapidjson::Writer<rapidjson::StringBuffer> writer(strbuf);
		options["linearAlgebra"].Accept(writer);
		linearAlgebra.jsonInit(strbuf.GetString());
	}

	// Copy node coordinates
	const auto& gNodes = mesh.getGeometry()->getNodes();
	for (size_t rNodes=0; rNodes<nbNodes; rNodes++)
	{
		X[rNodes][0] = gNodes[rNodes][0];
		X[rNodes][1] = gNodes[rNodes][1];
	}
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: deltat, t_n
 * Out variables: t_nplus1
 */
void Boussinesq::computeTn() noexcept
{
	t_nplus1 = t_n + deltat;
}

/**
 * Job iniB called @1.0 in executeTimeLoopN method.
 * In variables: Dt_n0, H_n0, M_n, M_n0, Mm_n0, N_n0, Nm_n0, deltat, deltax, deltay, g
 * Out variables: B_n0
 */
void Boussinesq::iniB() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ipId(mesh.getRightCell(icId));
			const size_t ipCells(ipId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			const Id itId(mesh.getTopCell(icId));
			const size_t itCells(itId);
			const Id itmId(mesh.getLeftCell(itId));
			const size_t itmCells(itmId);
			B_n0.setValue(icCells, M_n0[icCells] + g * (deltat / deltax) * ((Dt_n0[icCells] + Dt_n0[ipCells]) / 2) * (H_n0[ipCells] - H_n0[icCells]) - Dt_n0[icCells] * Dt_n0[icCells] / (3 * deltax * deltax) * (Mm_n0[imCells] - 2 * Mm_n0[icCells] + Mm_n0[ipCells]) + Dt_n0[icCells] * Dt_n0[icCells] / (3 * deltax * deltay) * (N_n0[itCells] - N_n0[itmCells] - N_n0[icCells] + N_n0[imCells] - (Nm_n0[itCells] - Nm_n0[itmCells] - Nm_n0[icCells] + Nm_n0[imCells])) - (deltat / (Dt_n0[icCells] * deltax)) * M_n0[icCells] * (M_n0[icCells] - M_n0[imCells]) - (deltat / (Dt_n0[icCells] * deltay)) * N_n0[icCells] * (M_n0[icCells] - M_n[ibCells]));
		});
	}
}

/**
 * Job iniCenter called @1.0 in simulate method.
 * In variables: X
 * Out variables: center
 */
void Boussinesq::iniCenter() noexcept
{
	parallel_exec(nbCells, [&](const size_t& jCells)
	{
		const Id jId(jCells);
		RealArray1D<2> reduction0({0.0, 0.0});
		{
			const auto nodesOfCellJ(mesh.getNodesOfCell(jId));
			const size_t nbNodesOfCellJ(nodesOfCellJ.size());
			for (size_t rNodesOfCellJ=0; rNodesOfCellJ<nbNodesOfCellJ; rNodesOfCellJ++)
			{
				const Id rId(nodesOfCellJ[rNodesOfCellJ]);
				const size_t rNodes(rId);
				reduction0 = boussinesqfreefuncs::sumR1(reduction0, X[rNodes]);
			}
		}
		center[jCells] = (boussinesqfreefuncs::operatorMult(0.25, reduction0));
	});
}

/**
 * Job iniMcurr called @1.0 in executeTimeLoopK method.
 * In variables: M_n, epsilon
 * Out variables: Mcurr_nplus1_k
 */
void Boussinesq::iniMcurr() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			if (std::abs(M_n[icCells]) < 0) 
				Mcurr_nplus1_k.setValue(icCells, M_n[icCells] + 2 * epsilon);
			else
				Mcurr_nplus1_k.setValue(icCells, 0.0);
		});
	}
}

/**
 * Job iniNcurr called @1.0 in executeTimeLoopK method.
 * In variables: N_n, epsilon
 * Out variables: Ncurr_nplus1_k
 */
void Boussinesq::iniNcurr() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			if (std::abs(N_n[icCells]) < 0) 
				Ncurr_nplus1_k.setValue(icCells, N_n[icCells] + 2 * epsilon);
			else
				Ncurr_nplus1_k.setValue(icCells, 0.0);
		});
	}
}

/**
 * Job initM called @1.0 in simulate method.
 * In variables: 
 * Out variables: M_n0
 */
void Boussinesq::initM() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		M_n0[icCells] = 0.0;
	});
}

/**
 * Job initMm called @1.0 in simulate method.
 * In variables: 
 * Out variables: Mm_n0
 */
void Boussinesq::initMm() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Mm_n0[icCells] = 0.0;
	});
}

/**
 * Job initN called @1.0 in simulate method.
 * In variables: 
 * Out variables: N_n0
 */
void Boussinesq::initN() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		N_n0[icCells] = 0.0;
	});
}

/**
 * Job initNm called @1.0 in simulate method.
 * In variables: 
 * Out variables: Nm_n0
 */
void Boussinesq::initNm() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Nm_n0[icCells] = 0.0;
	});
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void Boussinesq::initTime() noexcept
{
	t_n0 = 0.0;
}

/**
 * Job setUpTimeLoopK called @1.0 in executeTimeLoopN method.
 * In variables: B_n, D_n, Mcurr_n, Ncurr_n
 * Out variables: B_nplus1_k, D_nplus1_k, Mcurr_nplus1_k, Ncurr_nplus1_k
 */
void Boussinesq::setUpTimeLoopK() noexcept
{
	B_nplus1_k = B_n;
	D_nplus1_k = D_n;
	Mcurr_nplus1_k = Mcurr_n;
	Ncurr_nplus1_k = Ncurr_n;
}

/**
 * Job updateA called @1.0 in executeTimeLoopN method.
 * In variables: Dt_n, deltax
 * Out variables: A
 */
void Boussinesq::updateA() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			A.setValue(icCells, icCells, 2 * (Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltax)) + 1);
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ipId(mesh.getRightCell(icId));
			const size_t ipCells(ipId);
			A.setValue(icCells, ipCells, -Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltax));
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			A.setValue(icCells, imCells, -Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltax));
		});
	}
}

/**
 * Job updateC called @1.0 in executeTimeLoopN method.
 * In variables: Dt_n, deltay
 * Out variables: C
 */
void Boussinesq::updateC() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			C.setValue(icCells, icCells, 2 * (Dt_n[icCells] * Dt_n[icCells] / (3 * deltay * deltay)) + 1);
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id itId(mesh.getTopCell(icId));
			const size_t itCells(itId);
			C.setValue(icCells, itCells, -Dt_n[icCells] * Dt_n[icCells] / (3 * deltay * deltay));
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			C.setValue(icCells, ibCells, -Dt_n[icCells] * Dt_n[icCells] / (3 * deltay * deltay));
		});
	}
}

/**
 * Job updateMm called @1.0 in executeTimeLoopN method.
 * In variables: M_n
 * Out variables: Mm_nplus1
 */
void Boussinesq::updateMm() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Mm_nplus1[icCells] = M_n[icCells];
	});
}

/**
 * Job updateMouter called @1.0 in simulate method.
 * In variables: 
 * Out variables: M_nplus1
 */
void Boussinesq::updateMouter() noexcept
{
	{
		const auto topCells(mesh.getGroup("TopCells"));
		parallel_exec(nbTopCells, [&](const size_t& tcTopCells)
		{
			const Id tcId(topCells[tcTopCells]);
			const size_t tcCells(tcId);
			M_nplus1[tcCells] = 0.0;
		});
	}
	{
		const auto bottomCells(mesh.getGroup("BottomCells"));
		parallel_exec(nbBottomCells, [&](const size_t& bcBottomCells)
		{
			const Id bcId(bottomCells[bcBottomCells]);
			const size_t bcCells(bcId);
			M_nplus1[bcCells] = 0.0;
		});
	}
	{
		const auto leftCells(mesh.getGroup("LeftCells"));
		parallel_exec(nbLeftCells, [&](const size_t& lcLeftCells)
		{
			const Id lcId(leftCells[lcLeftCells]);
			const size_t lcCells(lcId);
			M_nplus1[lcCells] = 0.0;
		});
	}
	{
		const auto rightCells(mesh.getGroup("RightCells"));
		parallel_exec(nbRightCells, [&](const size_t& rcRightCells)
		{
			const Id rcId(rightCells[rcRightCells]);
			const size_t rcCells(rcId);
			M_nplus1[rcCells] = 0.0;
		});
	}
}

/**
 * Job updateNm called @1.0 in executeTimeLoopN method.
 * In variables: N_n
 * Out variables: Nm_nplus1
 */
void Boussinesq::updateNm() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Nm_nplus1[icCells] = N_n[icCells];
	});
}

/**
 * Job updateNouter called @1.0 in simulate method.
 * In variables: 
 * Out variables: N_nplus1
 */
void Boussinesq::updateNouter() noexcept
{
	{
		const auto topCells(mesh.getGroup("TopCells"));
		parallel_exec(nbTopCells, [&](const size_t& tcTopCells)
		{
			const Id tcId(topCells[tcTopCells]);
			const size_t tcCells(tcId);
			N_nplus1[tcCells] = 0.0;
		});
	}
	{
		const auto bottomCells(mesh.getGroup("BottomCells"));
		parallel_exec(nbBottomCells, [&](const size_t& bcBottomCells)
		{
			const Id bcId(bottomCells[bcBottomCells]);
			const size_t bcCells(bcId);
			N_nplus1[bcCells] = 0.0;
		});
	}
	{
		const auto leftCells(mesh.getGroup("LeftCells"));
		parallel_exec(nbLeftCells, [&](const size_t& lcLeftCells)
		{
			const Id lcId(leftCells[lcLeftCells]);
			const size_t lcCells(lcId);
			N_nplus1[lcCells] = 0.0;
		});
	}
	{
		const auto rightCells(mesh.getGroup("RightCells"));
		parallel_exec(nbRightCells, [&](const size_t& rcRightCells)
		{
			const Id rcId(rightCells[rcRightCells]);
			const size_t rcCells(rcId);
			N_nplus1[rcCells] = 0.0;
		});
	}
}

/**
 * Job executeTimeLoopK called @2.0 in executeTimeLoopN method.
 * In variables: B_nplus1_k, D_nplus1_k, Mcurr_nplus1_k, Ncurr_nplus1_k, epsilon, k, maxIterationsK, residual
 * Out variables: B_nplus1_kplus1, D_nplus1_kplus1, Mcurr_nplus1_kplus1, Ncurr_nplus1_kplus1
 */
void Boussinesq::executeTimeLoopK() noexcept
{
	k = 0;
	bool continueLoop = true;
	do
	{
		k++;
		iniMcurr(); // @1.0
		iniNcurr(); // @1.0
		updateB(); // @2.0
		updateMcurr(); // @3.0
		updateD(); // @4.0
		updateNcurr(); // @5.0
		computeResidual(); // @6.0
		
	
		// Evaluate loop condition with variables at time n
		continueLoop = (residual > epsilon && k < maxIterationsK);
	
		B_nplus1_k = B_nplus1_kplus1;
		D_nplus1_k = D_nplus1_kplus1;
		Mcurr_nplus1_k = Mcurr_nplus1_kplus1;
		Ncurr_nplus1_k = Ncurr_nplus1_kplus1;
	} while (continueLoop);
}

/**
 * Job initDijini called @2.0 in simulate method.
 * In variables: Dini, Dup, LX, center, loadBathy
 * Out variables: Dijini
 */
void Boussinesq::initDijini() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		for (size_t icInnerCells=0; icInnerCells<nbInnerCells; icInnerCells++)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			if (loadBathy) 
				Dijini[icCells] = bathyLib.nextDepth();
			else
				Dijini[icCells] = Dini + center[icCells][0] * (Dup - Dini) / (LX);
		}
	}
}

/**
 * Job initHini called @2.0 in simulate method.
 * In variables: Amp, Sigma, X0, Y0, center, loadWave, waveMode
 * Out variables: Hini
 */
void Boussinesq::initHini() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		for (size_t icInnerCells=0; icInnerCells<nbInnerCells; icInnerCells++)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			if (loadWave) 
				Hini[icCells] = bathyLib.nextWaveHeight();
			else
				if (waveMode == 1) 
				if (center[icCells][0] < (X0 / 2.0)) 
				Hini[icCells] = Amp * std::sin(center[icCells][0] * (2 * 3.1415 / X0));
			else
				Hini[icCells] = 0.0;
			else
				if (waveMode == 2) 
				Hini[icCells] = Amp * std::exp(-0.5 * (center[icCells][0] - X0) * (center[icCells][0] - X0) / (Sigma * Sigma)) * std::exp(-0.5 * (center[icCells][1] - Y0) * (center[icCells][1] - Y0) / (Sigma * Sigma));
			else
				if (waveMode == 3) 
				Hini[icCells] = Amp * std::exp(-0.5 * (center[icCells][0] - X0) * (center[icCells][0] - X0) / (Sigma * Sigma));
		}
	}
}

/**
 * Job updateB called @2.0 in executeTimeLoopK method.
 * In variables: Dt_n, H_n, M_n, Mm_n, N_n, Ncurr_nplus1_k, Nm_n, deltat, deltax, deltay, g
 * Out variables: B_nplus1_k
 */
void Boussinesq::updateB() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ipId(mesh.getRightCell(icId));
			const size_t ipCells(ipId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			const Id itId(mesh.getTopCell(icId));
			const size_t itCells(itId);
			const Id itmId(mesh.getLeftCell(itId));
			const size_t itmCells(itmId);
			B_nplus1_k.setValue(icCells, M_n[icCells] + g * (deltat / deltax) * ((Dt_n[icCells] + Dt_n[ipCells]) / 2) * (H_n[ipCells] - H_n[icCells]) - Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltax) * (Mm_n[imCells] - 2 * Mm_n[icCells] + Mm_n[ipCells]) + Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltay) * (Ncurr_nplus1_k.getValue(itCells) - Ncurr_nplus1_k.getValue(itmCells) - Ncurr_nplus1_k.getValue(icCells) + Ncurr_nplus1_k.getValue(imCells) - (Nm_n[itCells] - Nm_n[itmCells] - Nm_n[icCells] + Nm_n[imCells])) - (deltat / (Dt_n[icCells] * deltax)) * M_n[icCells] * (M_n[icCells] - M_n[imCells]) - (deltat / (Dt_n[icCells] * deltay)) * N_n[icCells] * (M_n[icCells] - M_n[ibCells]));
		});
	}
}

/**
 * Job initDij called @3.0 in simulate method.
 * In variables: Dijini
 * Out variables: Dij
 */
void Boussinesq::initDij() noexcept
{
	{
		const auto topCells(mesh.getGroup("TopCells"));
		parallel_exec(nbTopCells, [&](const size_t& tcTopCells)
		{
			const Id tcId(topCells[tcTopCells]);
			const size_t tcCells(tcId);
			const Id bcId(mesh.getBottomCell(tcId));
			const size_t bcCells(bcId);
			Dij[tcCells] = Dijini[bcCells];
		});
	}
	{
		const auto bottomCells(mesh.getGroup("BottomCells"));
		parallel_exec(nbBottomCells, [&](const size_t& bcBottomCells)
		{
			const Id bcId(bottomCells[bcBottomCells]);
			const size_t bcCells(bcId);
			const Id tcId(mesh.getTopCell(bcId));
			const size_t tcCells(tcId);
			Dij[bcCells] = Dijini[tcCells];
		});
	}
	{
		const auto leftCells(mesh.getGroup("LeftCells"));
		parallel_exec(nbLeftCells, [&](const size_t& lcLeftCells)
		{
			const Id lcId(leftCells[lcLeftCells]);
			const size_t lcCells(lcId);
			const Id rcId(mesh.getRightCell(lcId));
			const size_t rcCells(rcId);
			Dij[lcCells] = Dijini[rcCells];
		});
	}
	{
		const auto rightCells(mesh.getGroup("RightCells"));
		parallel_exec(nbRightCells, [&](const size_t& rcRightCells)
		{
			const Id rcId(rightCells[rcRightCells]);
			const size_t rcCells(rcId);
			const Id lcId(mesh.getLeftCell(rcId));
			const size_t lcCells(lcId);
			Dij[rcCells] = Dijini[lcCells];
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			Dij[icCells] = Dijini[icCells];
		});
	}
}

/**
 * Job initH called @3.0 in simulate method.
 * In variables: Hini
 * Out variables: H_n0
 */
void Boussinesq::initH() noexcept
{
	{
		const auto topCells(mesh.getGroup("TopCells"));
		parallel_exec(nbTopCells, [&](const size_t& tTopCells)
		{
			const Id tId(topCells[tTopCells]);
			const size_t tCells(tId);
			const Id btId(mesh.getBottomCell(tId));
			const size_t btCells(btId);
			H_n0[tCells] = Hini[btCells];
		});
	}
	{
		const auto bottomCells(mesh.getGroup("BottomCells"));
		parallel_exec(nbBottomCells, [&](const size_t& bBottomCells)
		{
			const Id bId(bottomCells[bBottomCells]);
			const size_t bCells(bId);
			const Id tbId(mesh.getTopCell(bId));
			const size_t tbCells(tbId);
			H_n0[bCells] = Hini[tbCells];
		});
	}
	{
		const auto leftCells(mesh.getGroup("LeftCells"));
		parallel_exec(nbLeftCells, [&](const size_t& lLeftCells)
		{
			const Id lId(leftCells[lLeftCells]);
			const size_t lCells(lId);
			const Id rlId(mesh.getRightCell(lId));
			const size_t rlCells(rlId);
			H_n0[lCells] = Hini[rlCells];
		});
	}
	{
		const auto rightCells(mesh.getGroup("RightCells"));
		parallel_exec(nbRightCells, [&](const size_t& rRightCells)
		{
			const Id rId(rightCells[rRightCells]);
			const size_t rCells(rId);
			const Id lrId(mesh.getLeftCell(rId));
			const size_t lrCells(lrId);
			H_n0[rCells] = Hini[lrCells];
		});
	}
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			H_n0[icCells] = Hini[icCells];
		});
	}
}

/**
 * Job tearDownTimeLoopK called @3.0 in executeTimeLoopN method.
 * In variables: B_nplus1_kplus1, D_nplus1_kplus1, Mcurr_nplus1_kplus1, Ncurr_nplus1_kplus1
 * Out variables: B_nplus1, D_nplus1, Mcurr_nplus1, Ncurr_nplus1
 */
void Boussinesq::tearDownTimeLoopK() noexcept
{
	B_nplus1 = B_nplus1_kplus1;
	D_nplus1 = D_nplus1_kplus1;
	Mcurr_nplus1 = Mcurr_nplus1_kplus1;
	Ncurr_nplus1 = Ncurr_nplus1_kplus1;
}

/**
 * Job updateMcurr called @3.0 in executeTimeLoopK method.
 * In variables: A, B_nplus1_k
 * Out variables: Mcurr_nplus1_kplus1
 */
void Boussinesq::updateMcurr() noexcept
{
	Mcurr_nplus1_kplus1 = linearAlgebra.solveLinearSystem(A, B_nplus1_k);
}

/**
 * Job initDt called @4.0 in simulate method.
 * In variables: Dini, H_n0
 * Out variables: Dt_n0
 */
void Boussinesq::initDt() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Dt_n0[icCells] = Dini + H_n0[icCells];
	});
}

/**
 * Job updateD called @4.0 in executeTimeLoopK method.
 * In variables: Dt_n, H_n, M_n, Mcurr_nplus1_kplus1, Mm_n, N_n, Nm_n, deltat, deltax, deltay, g
 * Out variables: D_nplus1_k
 */
void Boussinesq::updateD() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ipId(mesh.getRightCell(icId));
			const size_t ipCells(ipId);
			const Id itId(mesh.getTopCell(icId));
			const size_t itCells(itId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			const Id ibpId(mesh.getRightCell(ibId));
			const size_t ibpCells(ibpId);
			D_nplus1_k.setValue(icCells, N_n[icCells] + g * (deltat / deltay) * ((Dt_n[icCells] + Dt_n[itCells]) / 2) * (H_n[itCells] - H_n[icCells]) - Dt_n[icCells] * Dt_n[icCells] / (3 * deltay * deltay) * (Nm_n[itCells] - 2 * Nm_n[icCells] + Nm_n[ibCells]) + Dt_n[icCells] * Dt_n[icCells] / (3 * deltax * deltay) * (Mcurr_nplus1_kplus1.getValue(ipCells) - Mcurr_nplus1_kplus1.getValue(ibpCells) - Mcurr_nplus1_kplus1.getValue(icCells) + Mcurr_nplus1_kplus1.getValue(ibCells) - (Mm_n[ipCells] - Mm_n[ibpCells] - Mm_n[icCells] + Mm_n[ibCells])) - (deltat / (Dt_n[icCells] * deltax)) * M_n[icCells] * (N_n[icCells] - N_n[imCells]) - (deltat / (Dt_n[icCells] * deltay)) * N_n[icCells] * (N_n[icCells] - N_n[ibCells]));
		});
	}
}

/**
 * Job updateM called @4.0 in executeTimeLoopN method.
 * In variables: Mcurr_nplus1
 * Out variables: Mcalc_nplus1
 */
void Boussinesq::updateM() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			Mcalc_nplus1[icCells] = Mcurr_nplus1.getValue(icCells);
		});
	}
}

/**
 * Job updateN called @4.0 in executeTimeLoopN method.
 * In variables: Ncurr_nplus1
 * Out variables: Ncalc_nplus1
 */
void Boussinesq::updateN() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			Ncalc_nplus1[icCells] = Ncurr_nplus1.getValue(icCells);
		});
	}
}

/**
 * Job iniD called @5.0 in simulate method.
 * In variables: Dt_n0, H_n0, M_n0, Mm_n0, N_n0, Nm_n0, deltat, deltax, deltay, g
 * Out variables: D_n0
 */
void Boussinesq::iniD() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id ipId(mesh.getRightCell(icId));
			const size_t ipCells(ipId);
			const Id itId(mesh.getTopCell(icId));
			const size_t itCells(itId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			const Id ibpId(mesh.getRightCell(ibId));
			const size_t ibpCells(ibpId);
			D_n0.setValue(icCells, N_n0[icCells] + g * (deltat / deltay) * ((Dt_n0[icCells] + Dt_n0[itCells]) / 2) * (H_n0[itCells] - H_n0[icCells]) - Dt_n0[icCells] * Dt_n0[icCells] / (3 * deltay * deltay) * (Nm_n0[itCells] - 2 * Nm_n0[icCells] + Nm_n0[ibCells]) + Dt_n0[icCells] * Dt_n0[icCells] / (3 * deltax * deltay) * (M_n0[ipCells] - M_n0[ibpCells] - M_n0[icCells] + M_n0[ibCells] - (Mm_n0[ipCells] - Mm_n0[ibpCells] - Mm_n0[icCells] + Mm_n0[ibCells])) - (deltat / (Dt_n0[icCells] * deltax)) * M_n0[icCells] * (N_n0[icCells] - N_n0[imCells]) - (deltat / (Dt_n0[icCells] * deltay)) * N_n0[icCells] * (N_n0[icCells] - N_n0[ibCells]));
		});
	}
}

/**
 * Job updateMinner called @5.0 in executeTimeLoopN method.
 * In variables: Mcalc_nplus1
 * Out variables: M_nplus1
 */
void Boussinesq::updateMinner() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			M_nplus1[icCells] = Mcalc_nplus1[icCells];
		});
	}
}

/**
 * Job updateNcurr called @5.0 in executeTimeLoopK method.
 * In variables: C, D_nplus1_k
 * Out variables: Ncurr_nplus1_kplus1
 */
void Boussinesq::updateNcurr() noexcept
{
	Ncurr_nplus1_kplus1 = linearAlgebra.solveLinearSystem(C, D_nplus1_k);
}

/**
 * Job updateNinner called @5.0 in executeTimeLoopN method.
 * In variables: Ncalc_nplus1
 * Out variables: N_nplus1
 */
void Boussinesq::updateNinner() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			N_nplus1[icCells] = Ncalc_nplus1[icCells];
		});
	}
}

/**
 * Job computeResidual called @6.0 in executeTimeLoopK method.
 * In variables: Mcurr_nplus1_k, Mcurr_nplus1_kplus1, Ncurr_nplus1_k, Ncurr_nplus1_kplus1
 * Out variables: residual
 */
void Boussinesq::computeResidual() noexcept
{
	double reduction0;
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		reduction0 = parallel_reduce(nbInnerCells, double(-numeric_limits<double>::max()), [&](double& accu, const size_t& jInnerCells)
			{
				const Id jId(innerCells[jInnerCells]);
				const size_t jCells(jId);
				return (accu = boussinesqfreefuncs::maxR0(accu, std::abs(Mcurr_nplus1_kplus1.getValue(jCells) - Mcurr_nplus1_k.getValue(jCells))));
			},
			&boussinesqfreefuncs::maxR0);
	}
	double reduction1;
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		reduction1 = parallel_reduce(nbInnerCells, double(-numeric_limits<double>::max()), [&](double& accu, const size_t& jInnerCells)
			{
				const Id jId(innerCells[jInnerCells]);
				const size_t jCells(jId);
				return (accu = boussinesqfreefuncs::maxR0(accu, std::abs(Ncurr_nplus1_kplus1.getValue(jCells) - Ncurr_nplus1_k.getValue(jCells))));
			},
			&boussinesqfreefuncs::maxR0);
	}
	residual = std::max(reduction0, reduction1);
}

/**
 * Job setUpTimeLoopN called @6.0 in simulate method.
 * In variables: B_n0, D_n0, Dt_n0, H_n0, M_n0, Mm_n0, N_n0, Nm_n0, t_n0
 * Out variables: B_n, D_n, Dt_n, H_n, M_n, Mm_n, N_n, Nm_n, t_n
 */
void Boussinesq::setUpTimeLoopN() noexcept
{
	t_n = t_n0;
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		H_n[i1Cells] = H_n0[i1Cells];
	});
	B_n = B_n0;
	D_n = D_n0;
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		M_n[i1Cells] = M_n0[i1Cells];
	});
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		Mm_n[i1Cells] = Mm_n0[i1Cells];
	});
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		N_n[i1Cells] = N_n0[i1Cells];
	});
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		Nm_n[i1Cells] = Nm_n0[i1Cells];
	});
	parallel_exec(nbCells, [&](const size_t& i1Cells)
	{
		Dt_n[i1Cells] = Dt_n0[i1Cells];
	});
}

/**
 * Job updateH called @6.0 in executeTimeLoopN method.
 * In variables: H_n, M_nplus1, N_nplus1, deltat, deltax, deltay
 * Out variables: Hcalc_nplus1
 */
void Boussinesq::updateH() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			const Id imId(mesh.getLeftCell(icId));
			const size_t imCells(imId);
			const Id ibId(mesh.getBottomCell(icId));
			const size_t ibCells(ibId);
			Hcalc_nplus1[icCells] = H_n[icCells] - (deltat / deltax) * (M_nplus1[icCells] - M_nplus1[imCells]) - (deltat / deltay) * (N_nplus1[icCells] - N_nplus1[ibCells]);
		});
	}
}

/**
 * Job executeTimeLoopN called @7.0 in simulate method.
 * In variables: B_n, D_n, Dt_n, H_n, Hcalc_n, M_n, Mcalc_n, Mcurr_n, Mm_n, N_n, Ncalc_n, Ncurr_n, Nm_n, lastDump, maxIter, n, outputPeriod, stopTime, t_n, t_nplus1
 * Out variables: B_nplus1, D_nplus1, Dt_nplus1, H_nplus1, Hcalc_nplus1, M_nplus1, Mcalc_nplus1, Mcurr_nplus1, Mm_nplus1, N_nplus1, Ncalc_nplus1, Ncurr_nplus1, Nm_nplus1, t_nplus1
 */
void Boussinesq::executeTimeLoopN() noexcept
{
	n = 0;
	bool continueLoop = true;
	do
	{
		globalTimer.start();
		cpuTimer.start();
		n++;
		if (writer != NULL && !writer->isDisabled() && n >= lastDump + outputPeriod)
			dumpVariables(n);
		if (n!=1)
			std::cout << "[" << __CYAN__ << __BOLD__ << setw(3) << n << __RESET__ "] t = " << __BOLD__
				<< setiosflags(std::ios::scientific) << setprecision(8) << setw(16) << t_n << __RESET__;
	
		computeTn(); // @1.0
		iniB(); // @1.0
		setUpTimeLoopK(); // @1.0
		updateA(); // @1.0
		updateC(); // @1.0
		updateMm(); // @1.0
		updateNm(); // @1.0
		executeTimeLoopK(); // @2.0
		tearDownTimeLoopK(); // @3.0
		updateM(); // @4.0
		updateN(); // @4.0
		updateMinner(); // @5.0
		updateNinner(); // @5.0
		updateH(); // @6.0
		updateHinner(); // @7.0
		updateHouter(); // @7.0
		updateDt(); // @8.0
		
	
		// Evaluate loop condition with variables at time n
		continueLoop = (t_nplus1 < stopTime && n < maxIter);
	
		t_n = t_nplus1;
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			H_n[i1Cells] = H_nplus1[i1Cells];
		});
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Hcalc_n[i1Cells] = Hcalc_nplus1[i1Cells];
		});
		B_n = B_nplus1;
		D_n = D_nplus1;
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Mcalc_n[i1Cells] = Mcalc_nplus1[i1Cells];
		});
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			M_n[i1Cells] = M_nplus1[i1Cells];
		});
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Mm_n[i1Cells] = Mm_nplus1[i1Cells];
		});
		Mcurr_n = Mcurr_nplus1;
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Ncalc_n[i1Cells] = Ncalc_nplus1[i1Cells];
		});
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			N_n[i1Cells] = N_nplus1[i1Cells];
		});
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Nm_n[i1Cells] = Nm_nplus1[i1Cells];
		});
		Ncurr_n = Ncurr_nplus1;
		parallel_exec(nbCells, [&](const size_t& i1Cells)
		{
			Dt_n[i1Cells] = Dt_nplus1[i1Cells];
		});
	
		cpuTimer.stop();
		globalTimer.stop();
	
		// Timers display
		if (writer != NULL && !writer->isDisabled())
			std::cout << " {CPU: " << __BLUE__ << cpuTimer.print(true) << __RESET__ ", IO: " << __BLUE__ << ioTimer.print(true) << __RESET__ "} ";
		else
			std::cout << " {CPU: " << __BLUE__ << cpuTimer.print(true) << __RESET__ ", IO: " << __RED__ << "none" << __RESET__ << "} ";
		
		// Progress
		std::cout << progress_bar(n, maxIter, t_n, stopTime, 25);
		std::cout << __BOLD__ << __CYAN__ << Timer::print(
			eta(n, maxIter, t_n, stopTime, deltat, globalTimer), true)
			<< __RESET__ << "\r";
		std::cout.flush();
	
		cpuTimer.reset();
		ioTimer.reset();
	} while (continueLoop);
	if (writer != NULL && !writer->isDisabled())
		dumpVariables(n+1, false);
}

/**
 * Job updateHinner called @7.0 in executeTimeLoopN method.
 * In variables: Hcalc_nplus1
 * Out variables: H_nplus1
 */
void Boussinesq::updateHinner() noexcept
{
	{
		const auto innerCells(mesh.getGroup("InnerCells"));
		parallel_exec(nbInnerCells, [&](const size_t& icInnerCells)
		{
			const Id icId(innerCells[icInnerCells]);
			const size_t icCells(icId);
			H_nplus1[icCells] = Hcalc_nplus1[icCells];
		});
	}
}

/**
 * Job updateHouter called @7.0 in executeTimeLoopN method.
 * In variables: Hcalc_nplus1
 * Out variables: H_nplus1
 */
void Boussinesq::updateHouter() noexcept
{
	{
		const auto topCells(mesh.getGroup("TopCells"));
		parallel_exec(nbTopCells, [&](const size_t& tcTopCells)
		{
			const Id tcId(topCells[tcTopCells]);
			const size_t tcCells(tcId);
			const Id bcId(mesh.getBottomCell(tcId));
			const size_t bcCells(bcId);
			H_nplus1[tcCells] = Hcalc_nplus1[bcCells];
		});
	}
	{
		const auto bottomCells(mesh.getGroup("BottomCells"));
		parallel_exec(nbBottomCells, [&](const size_t& bcBottomCells)
		{
			const Id bcId(bottomCells[bcBottomCells]);
			const size_t bcCells(bcId);
			const Id tcId(mesh.getTopCell(bcId));
			const size_t tcCells(tcId);
			H_nplus1[bcCells] = Hcalc_nplus1[tcCells];
		});
	}
	{
		const auto leftCells(mesh.getGroup("LeftCells"));
		parallel_exec(nbLeftCells, [&](const size_t& lcLeftCells)
		{
			const Id lcId(leftCells[lcLeftCells]);
			const size_t lcCells(lcId);
			const Id rcId(mesh.getRightCell(lcId));
			const size_t rcCells(rcId);
			H_nplus1[lcCells] = Hcalc_nplus1[rcCells];
		});
	}
	{
		const auto rightCells(mesh.getGroup("RightCells"));
		parallel_exec(nbRightCells, [&](const size_t& rcRightCells)
		{
			const Id rcId(rightCells[rcRightCells]);
			const size_t rcCells(rcId);
			const Id lcId(mesh.getLeftCell(rcId));
			const size_t lcCells(lcId);
			H_nplus1[rcCells] = Hcalc_nplus1[lcCells];
		});
	}
}

/**
 * Job updateDt called @8.0 in executeTimeLoopN method.
 * In variables: Dini, H_nplus1
 * Out variables: Dt_nplus1
 */
void Boussinesq::updateDt() noexcept
{
	parallel_exec(nbCells, [&](const size_t& icCells)
	{
		Dt_nplus1[icCells] = -Dini + H_nplus1[icCells];
	});
}

void Boussinesq::dumpVariables(int iteration, bool useTimer)
{
	if (writer != NULL && !writer->isDisabled())
	{
		if (useTimer)
		{
			cpuTimer.stop();
			ioTimer.start();
		}
		auto quads = mesh.getGeometry()->getQuads();
		writer->startVtpFile(iteration, t_n, nbNodes, X.data(), nbCells, quads.data());
		writer->openNodeData();
		writer->closeNodeData();
		writer->openCellData();
		writer->openCellArray("hauteur", 0);
		for (size_t i=0 ; i<nbCells ; ++i)
			writer->write(H_n[i]);
		writer->closeCellArray();
		writer->openCellArray("B", 1);
		for (size_t i=0 ; i<nbCells ; ++i)
			writer->write(B_n.getValue(i));
		writer->closeCellArray();
		writer->closeCellData();
		writer->closeVtpFile();
		lastDump = n;
		if (useTimer)
		{
			ioTimer.stop();
			cpuTimer.start();
		}
	}
}

void Boussinesq::simulate()
{
	std::cout << "\n" << __BLUE_BKG__ << __YELLOW__ << __BOLD__ <<"\tStarting Boussinesq ..." << __RESET__ << "\n\n";
	
	std::cout << "[" << __GREEN__ << "TOPOLOGY" << __RESET__ << "]  HWLOC unavailable cannot get topological informations" << std::endl;
	
	if (writer != NULL && !writer->isDisabled())
		std::cout << "[" << __GREEN__ << "OUTPUT" << __RESET__ << "]    VTK files stored in " << __BOLD__ << writer->outputDirectory() << __RESET__ << " directory" << std::endl;
	else
		std::cout << "[" << __GREEN__ << "OUTPUT" << __RESET__ << "]    " << __BOLD__ << "Disabled" << __RESET__ << std::endl;

	iniCenter(); // @1.0
	initM(); // @1.0
	initMm(); // @1.0
	initN(); // @1.0
	initNm(); // @1.0
	initTime(); // @1.0
	updateMouter(); // @1.0
	updateNouter(); // @1.0
	initDijini(); // @2.0
	initHini(); // @2.0
	initDij(); // @3.0
	initH(); // @3.0
	initDt(); // @4.0
	iniD(); // @5.0
	setUpTimeLoopN(); // @6.0
	executeTimeLoopN(); // @7.0
	
	std::cout << "\nFinal time = " << t_n << endl;
	std::cout << __YELLOW__ << "\n\tDone ! Took " << __MAGENTA__ << __BOLD__ << globalTimer.print() << __RESET__ << std::endl;
	std::cout << "[CG] average iteration: " << linearAlgebra.m_info.m_nb_it / linearAlgebra.m_info.m_nb_call << std::endl;
}

int main(int argc, char* argv[]) 
{
	string dataFile;
	int ret = 0;
	
	if (argc == 2)
	{
		dataFile = argv[1];
	}
	else
	{
		std::cerr << "[ERROR] Wrong number of arguments. Expecting 1 arg: dataFile." << std::endl;
		std::cerr << "(Boussinesq.json)" << std::endl;
		return -1;
	}
	
	// read json dataFile
	ifstream ifs(dataFile);
	rapidjson::IStreamWrapper isw(ifs);
	rapidjson::Document d;
	d.ParseStream(isw);
	assert(d.IsObject());
	
	// Mesh instanciation
	CartesianMesh2D mesh;
	assert(d.HasMember("mesh"));
	rapidjson::StringBuffer strbuf;
	rapidjson::Writer<rapidjson::StringBuffer> writer(strbuf);
	d["mesh"].Accept(writer);
	mesh.jsonInit(strbuf.GetString());
	
	// Module instanciation(s)
	Boussinesq* boussinesq = new Boussinesq(mesh);
	if (d.HasMember("boussinesq"))
	{
		rapidjson::StringBuffer strbuf;
		rapidjson::Writer<rapidjson::StringBuffer> writer(strbuf);
		d["boussinesq"].Accept(writer);
		boussinesq->jsonInit(strbuf.GetString());
	}
	
	// Start simulation
	// Simulator must be a pointer when a finalize is needed at the end (Kokkos, omp...)
	boussinesq->simulate();
	
	delete boussinesq;
	return ret;
}
